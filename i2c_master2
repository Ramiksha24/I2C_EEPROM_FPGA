`timescale 1fs/1fs
module i2c_master #(
    parameter DEBUG = 0
)(input             i_clk,
  input             reset_n,
  input      [7:0]  i_addr_w_rw,
  input      [15:0] i_sub_addr,
  input             i_sub_len,
  input      [23:0] i_byte_len,
  input      [7:0]  i_data_write,
  input             req_trans,
  
  output reg [7:0]  data_out,
  output reg        valid_out,
  
  output            scl_out,
  input             scl_in,
  output            scl_oe,
  
  output            sda_out,
  input             sda_in,
  output            sda_oe,
  
  output reg        req_data_chunk,
  output reg        busy,
  output reg        nack
  
  `ifdef EXPOSE_DEBUG_SIGNALS
  ,
  output reg [3:0]  state,
  output reg [3:0]  next_state,
  output reg        reg_sda_o,
  output reg [7:0]  addr,
  output reg        rw,
  output reg [15:0] sub_addr,
  output reg        sub_len,
  output reg [23:0] byte_len,
  output reg        en_scl,
  output reg        byte_sent,
  output reg [23:0] num_byte_sent,
  output reg [2:0]  cntr,
  output reg [7:0]  byte_sr,
  output reg        read_sub_addr_sent_flag,
  output reg [7:0]  data_to_write,
  output reg [7:0]  data_in_sr,
  output reg        clk_i2c,
  output reg [15:0] clk_i2c_cntr,
  output reg        sda_prev,
  output reg [1:0]  sda_curr,
  output reg        scl_prev,
  output reg        scl_curr,
  output reg        ack_in_prog,
  output reg        ack_nack,
  output reg        en_end_indicator,
  output reg        grab_next_data,
  output reg        scl_is_high,
  output reg        scl_is_low,
  output reg [19:0] write_delay_cntr,
  output reg        release_sda_next  // NEW DEBUG SIGNAL
  `endif
);

localparam [3:0] IDLE        = 4'd0,
                 START       = 4'd1,
                 RESTART     = 4'd2,
                 SLAVE_ADDR  = 4'd3,
                 SUB_ADDR    = 4'd4,
                 READ        = 4'd5,
                 WRITE       = 4'd6,
                 GRAB_DATA   = 4'd7,
                 ACK_NACK_RX = 4'd8,
                 ACK_NACK_TX = 4'd9,
                 STOP        = 4'hA,
                 RELEASE_BUS = 4'hB,
                 WRITE_WAIT  = 4'hC;

localparam [15:0] DIV_100MHZ = 16'd125;
localparam [7:0]  START_IND_SETUP  = 70,
                  START_IND_HOLD   = 60,
                  DATA_SETUP_TIME  =  2,
                  DATA_HOLD_TIME   =  3,
                  STOP_IND_SETUP   = 60;

localparam [19:0] WRITE_CYCLE_DELAY = 20'd500000;

`ifndef EXPOSE_DEBUG_SIGNALS
reg [3:0]  state;
reg [3:0]  next_state;
reg        reg_sda_o;
reg [7:0]  addr;
reg        rw;
reg [15:0] sub_addr;
reg        sub_len;
reg [23:0] byte_len;
reg        en_scl;
reg        byte_sent;
reg [23:0] num_byte_sent;
reg [2:0]  cntr;
reg [7:0]  byte_sr;
reg        read_sub_addr_sent_flag;
reg [7:0]  data_to_write;
reg [7:0]  data_in_sr;
reg        clk_i2c;
reg [15:0] clk_i2c_cntr;
reg [1:0]  sda_curr;
reg        sda_prev;
reg        scl_prev, scl_curr;
reg        ack_in_prog;
reg        ack_nack;
reg        en_end_indicator;
reg        grab_next_data;
reg        scl_is_high;
reg        scl_is_low;
reg [19:0] write_delay_cntr;
reg        release_sda_next;  // NEW: Flag to release SDA on next cycle
`endif

reg [2:0] reset_sync;
wire reset_n_sync;

always @(posedge i_clk or negedge reset_n) begin
    if (!reset_n)
        reset_sync <= 3'b000;
    else
        reset_sync <= {reset_sync[1:0], 1'b1};
end

assign reset_n_sync = reset_sync[2];

// 400KHz clock generation
always@(posedge i_clk or negedge reset_n_sync) begin
    if(!reset_n_sync)
        {clk_i2c_cntr, clk_i2c} <= 17'b1;
    else if(!en_scl)
        {clk_i2c_cntr, clk_i2c} <= 17'b1;
    else begin
        clk_i2c_cntr <= clk_i2c_cntr + 1;
        if(clk_i2c_cntr == DIV_100MHZ-1) begin
            clk_i2c <= !clk_i2c;
            clk_i2c_cntr <= 0;
        end
    end
end

// Main FSM
always@(posedge i_clk or negedge reset_n_sync) begin
    if(!reset_n_sync) begin
        {data_out, valid_out} <= 0;
        {req_data_chunk, busy, nack} <= 0;
        {addr, rw, sub_addr, sub_len, byte_len, en_scl} <= 0;
        {byte_sent, num_byte_sent, cntr, byte_sr} <= 0;
        {read_sub_addr_sent_flag, data_to_write, data_in_sr} <= 0;
        {ack_nack, ack_in_prog, en_end_indicator} <= 0;
        {scl_is_high, scl_is_low, grab_next_data} <= 0;
        write_delay_cntr <= 0;
        release_sda_next <= 0;  // NEW
        reg_sda_o <= 1'bz;
        state <= IDLE;
        next_state <= IDLE;
    end
    else begin
        valid_out <= 1'b0;
        req_data_chunk <= 1'b0;
        
        // NEW: Handle early SDA release for ACK
        if(release_sda_next) begin
            reg_sda_o <= 1'bz;
            release_sda_next <= 1'b0;
        end
        
        case(state)
            IDLE: begin
                if(req_trans & !busy) begin
                    busy <= 1'b1;
                    state <= START;
                    next_state <= SLAVE_ADDR;
                    
                    addr <= i_addr_w_rw;
                    rw <= i_addr_w_rw[0];
                    sub_addr <= i_sub_len ? i_sub_addr : {i_sub_addr[7:0], 8'b0};
                    sub_len <= i_sub_len;
                    data_to_write <= i_data_write;
                    byte_len <= i_byte_len;
                    
                    en_scl <= 1'b1;
                    reg_sda_o <= 1'b1;
                    
                    nack <= 1'b0;
                    read_sub_addr_sent_flag <= 1'b0;
                    num_byte_sent <= 0;
                    byte_sent <= 1'b0;
                    write_delay_cntr <= 0;
                end
            end
            
            START: begin
                if(scl_prev & scl_curr & clk_i2c_cntr == START_IND_SETUP) begin
                    reg_sda_o <= 1'b0;
                    byte_sr <= {addr[7:1], 1'b0};
                    state <= SLAVE_ADDR;
                    $display("DUT: I2C MASTER | TIMESTAMP: %t | MESSAGE: START INDICATION!", $time);
                end
            end
            
            RESTART: begin
                if(!scl_curr & scl_prev) begin
                    reg_sda_o <= 1'b1;
                end
                
                if(!scl_prev & scl_curr) begin
                    scl_is_high <= 1'b1;
                end
                
                if(scl_is_high) begin
                    if(clk_i2c_cntr == START_IND_SETUP) begin
                        scl_is_high <= 1'b0;
                        reg_sda_o <= 1'b0;
                        state <= SLAVE_ADDR;
                        byte_sr <= addr;
                    end
                end
            end
            
            SLAVE_ADDR: begin
                // FIX: Release SDA BEFORE transitioning to ACK state
                if(byte_sent & cntr[0]) begin
                    byte_sent <= 1'b0;
                    next_state <= read_sub_addr_sent_flag ? READ : SUB_ADDR;
                    byte_sr <= sub_addr[15:8];
                    state <= ACK_NACK_RX;
                    reg_sda_o <= 1'bz;  // Release immediately
                    cntr <= 0;
                    $display("DUT: I2C MASTER | TIMESTAMP: %t | MESSAGE: SLAVE_ADDR SENT, SDA RELEASED", $time);
                end
                // CRITICAL FIX: Release SDA early when approaching 8th bit
                else if(cntr == 3'd7 && scl_is_low && clk_i2c_cntr == DATA_HOLD_TIME) begin
                    // This is the 8th bit being sent, prepare for ACK on next cycle
                    {byte_sent, cntr} <= {byte_sent, cntr} + 1;
                    reg_sda_o <= byte_sr[7];  // Send last bit
                    byte_sr <= {byte_sr[6:0], 1'b0};
                    scl_is_low <= 1'b0;
                    release_sda_next <= 1'b1;  // Flag to release on NEXT clock cycle
                end
                else begin
                    if(!scl_curr & scl_prev) begin
                        scl_is_low <= 1'b1;
                    end
                    
                    if(scl_is_low) begin
                        if(clk_i2c_cntr == DATA_HOLD_TIME) begin
                            {byte_sent, cntr} <= {byte_sent, cntr} + 1;
                            reg_sda_o <= byte_sr[7];
                            byte_sr <= {byte_sr[6:0], 1'b0};
                            scl_is_low <= 1'b0;
                        end
                    end
                end
            end
            
            SUB_ADDR: begin
                if(byte_sent & cntr[0]) begin
                    if(sub_len) begin
                        state <= ACK_NACK_RX;
                        next_state <= SUB_ADDR;
                        sub_len <= 1'b0;
                        byte_sr <= sub_addr[7:0];
                        $display("DUT: I2C MASTER | TIMESTAMP: %t | MESSAGE: MSB OF SUB ADDR SENT", $time);
                    end
                    else begin
                        next_state <= rw ? RESTART : WRITE;
                        byte_sr <= rw ? byte_sr : data_to_write;
                        read_sub_addr_sent_flag <= 1'b1;
                        $display("DUT: I2C MASTER | TIMESTAMP: %t | MESSAGE: SUB ADDR SENT", $time);
                    end
                    
                    cntr <= 0;
                    byte_sent <= 1'b0;
                    state <= ACK_NACK_RX;
                    reg_sda_o <= 1'bz;  // Release for ACK
                end
                // CRITICAL FIX: Same early release logic
                else if(cntr == 3'd7 && scl_is_low && clk_i2c_cntr == DATA_HOLD_TIME) begin
                    {byte_sent, cntr} <= {byte_sent, cntr} + 1;
                    reg_sda_o <= byte_sr[7];
                    byte_sr <= {byte_sr[6:0], 1'b0};
                    scl_is_low <= 1'b0;
                    release_sda_next <= 1'b1;
                end
                else begin
                    if(!scl_curr & scl_prev) begin
                        scl_is_low <= 1'b1;
                    end
                    
                    if(scl_is_low) begin
                        if(clk_i2c_cntr == DATA_HOLD_TIME) begin
                            scl_is_low <= 1'b0;
                            {byte_sent, cntr} <= {byte_sent, cntr} + 1;
                            reg_sda_o <= byte_sr[7];
                            byte_sr <= {byte_sr[6:0], 1'b0};
                        end
                    end
                end
            end
            
            READ: begin
                if(byte_sent) begin
                    byte_sent <= 1'b0;
                    data_out  <= data_in_sr;
                    valid_out <= 1'b1;
                    state <= ACK_NACK_TX;
                    next_state <= (num_byte_sent == byte_len-1) ? STOP : READ;
                    ack_nack <= num_byte_sent == byte_len-1;
                    num_byte_sent <= num_byte_sent + 1;
                    ack_in_prog <= 1'b1;
                    $display("DUT: I2C MASTER | TIMESTAMP: %t | MESSAGE: READ BYTE #%d SENT!", $time, num_byte_sent);
                end
                else begin
                    if(!scl_prev & scl_curr) begin
                        scl_is_high <= 1'b1;
                    end
                    
                    if(scl_is_high) begin
                        if(clk_i2c_cntr == START_IND_SETUP) begin
                            valid_out <= 1'b0;
                            {byte_sent, cntr} <= cntr + 1;
                            data_in_sr <= {data_in_sr[6:0], sda_prev};
                            scl_is_high <= 1'b0;
                        end
                    end
                end
            end
            
            WRITE: begin
                if(byte_sent & cntr[0]) begin
                    cntr <= 0;
                    byte_sent <= 1'b0;
                    state <= ACK_NACK_RX;
                    reg_sda_o <= 1'bz;
                    next_state <= (num_byte_sent == byte_len-1) ? STOP : GRAB_DATA;
                    num_byte_sent <= num_byte_sent + 1'b1;
                    grab_next_data <= 1'b1;
                    $display("DUT: I2C MASTER | TIMESTAMP: %t | MESSAGE: WRITE BYTE #%d SENT!", $time, num_byte_sent);
                end
                // CRITICAL FIX: Same early release logic
                else if(cntr == 3'd7 && scl_is_low && clk_i2c_cntr == DATA_HOLD_TIME) begin
                    {byte_sent, cntr} <= {byte_sent, cntr} + 1;
                    reg_sda_o <= byte_sr[7];
                    byte_sr <= {byte_sr[6:0], 1'b0};
                    scl_is_low <= 1'b0;
                    release_sda_next <= 1'b1;
                end
                else begin
                    if(!scl_curr & scl_prev) begin
                        scl_is_low <= 1'b1;
                    end
                    
                    if(scl_is_low) begin
                        if(clk_i2c_cntr == DATA_HOLD_TIME) begin
                            {byte_sent, cntr} <= {byte_sent, cntr} + 1;
                            reg_sda_o <= byte_sr[7];
                            byte_sr <= {byte_sr[6:0], 1'b0};
                            scl_is_low <= 1'b0;
                        end
                    end
                end
            end
            
            GRAB_DATA: begin
                if(grab_next_data) begin
                    req_data_chunk <= 1'b1;
                    grab_next_data <= 1'b0;
                end
                else begin
                    state <= WRITE;
                    byte_sr <= i_data_write;
                end
            end
            
            ACK_NACK_RX: begin
                if(!scl_prev & scl_curr) begin
                    scl_is_high <= 1'b1;
                end
                
                if(scl_is_high) begin
                    if(clk_i2c_cntr == START_IND_SETUP) begin
                        if(!sda_prev) begin
                            state <= next_state;
                            $display("DUT: I2C MASTER | TIMESTAMP: %t | MESSAGE: rx ACK encountered (sda_prev=%b)", $time, sda_prev);
                        end
                        else begin
                            $display("DUT: I2C MASTER | TIMESTAMP: %t | MESSAGE: rx NACK encountered (sda_prev=%b)", $time, sda_prev);
                            nack <= 1'b1;
                            busy <= 1'b0;
                            reg_sda_o <= 1'bz;
                            en_scl <= 1'b0;
                            state <= IDLE;
                        end
                        scl_is_high <= 1'b0;
                    end
                end
            end
            
            ACK_NACK_TX: begin
                if(!scl_curr & scl_prev) begin
                    scl_is_low <= 1'b1;
                end
                if(scl_is_low) begin
                    if(clk_i2c_cntr == DATA_HOLD_TIME) begin
                        if(ack_in_prog) begin
                            reg_sda_o <= ack_nack;
                            ack_in_prog <= 1'b0;
                        end
                        else begin
                            reg_sda_o <= next_state == STOP ? 1'b0 : 1'bz;
                            en_end_indicator <= next_state == STOP ? 1'b1 : en_end_indicator;
                            state <= next_state;
                        end
                        scl_is_low <= 1'b0;
                    end
                end
            end
            
            STOP: begin
                if(!scl_curr & scl_prev & !rw) begin
                    reg_sda_o <= 1'b0;
                    en_end_indicator <= 1'b1;
                end
                
                if(scl_curr & scl_prev & en_end_indicator) begin
                    scl_is_high <= 1'b1;
                    en_end_indicator <= 1'b0;
                end
                
                if(scl_is_high) begin
                    if(clk_i2c_cntr == STOP_IND_SETUP) begin
                        reg_sda_o <= 1'b1;
                        state <= RELEASE_BUS;
                        scl_is_high <= 1'b0;
                    end
                end
            end
            
            RELEASE_BUS: begin
                if(clk_i2c_cntr == DIV_100MHZ-3) begin
                    en_scl <= 1'b0;
                    reg_sda_o <= 1'bz;
                    
                    if(!rw) begin
                        state <= WRITE_WAIT;
                        write_delay_cntr <= 0;
                        $display("DUT: I2C MASTER | TIMESTAMP: %t | MESSAGE: Starting EEPROM write cycle delay (5ms)", $time);
                    end
                    else begin
                        state <= IDLE;
                        busy <= 1'b0;
                        $display("DUT: I2C MASTER | TIMESTAMP: %t | MESSAGE: Read complete, returning to IDLE", $time);
                    end
                end
            end
            
            WRITE_WAIT: begin
                write_delay_cntr <= write_delay_cntr + 1;
                
                if(write_delay_cntr == WRITE_CYCLE_DELAY - 1) begin
                    busy <= 1'b0;
                    state <= IDLE;
                    $display("DUT: I2C MASTER | TIMESTAMP: %t | MESSAGE: EEPROM write cycle complete, returning to IDLE", $time);
                end
            end
            
            default:
                state <= IDLE;
        endcase
    end
end

// SDA/SCL sampling
always @(negedge i_clk or negedge reset_n_sync) begin
    if (!reset_n_sync) begin
        {sda_curr, sda_prev} <= 0;
        {scl_curr, scl_prev} <= 0;
    end
    else begin
        sda_curr <= {sda_curr[0], sda_in};
        sda_prev <= sda_curr[1];
        scl_curr <= clk_i2c;
        scl_prev <= scl_curr;
    end
end

assign sda_out = (reg_sda_o === 1'bz) ? 1'b1 : reg_sda_o;
assign sda_oe  = (reg_sda_o !== 1'bz);

assign scl_out = clk_i2c;
assign scl_oe  = en_scl;

endmodule
